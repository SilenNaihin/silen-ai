# AUTOGENERATED! DO NOT EDIT! File to edit: ../../projects/utils/clean_mem.ipynb.

# %% auto 0
__all__ = ['get_current_notebook_memory', 'get_all_kernels_memory', 'get_system_memory', 'clean_current_notebook',
           'kill_specific_kernel', 'kill_all_kernels', 'check_variable_sizes']

# %% ../../projects/utils/clean_mem.ipynb 3
import os
import psutil
import sys

def get_current_notebook_memory():
    """Get memory usage of the current notebook/kernel"""
    process = psutil.Process(os.getpid())
    mem_info = process.memory_info()
    mem_mb = mem_info.rss / 1024 / 1024  # Convert to MB
    mem_gb = mem_mb / 1024
    
    print(f"Current Notebook (PID: {os.getpid()}):")
    print(f"  Memory Usage: {mem_mb:.2f} MB ({mem_gb:.2f} GB)")
    print(f"  CPU Usage: {process.cpu_percent(interval=1):.1f}%")
    
    # Show largest variables in memory
    print("\nLargest variables in memory:")
    vars_size = [(name, sys.getsizeof(obj) / (1024**2)) 
                 for name, obj in globals().items() 
                 if not name.startswith('_')]
    vars_size.sort(key=lambda x: x[1], reverse=True)
    
    for name, size_mb in vars_size[:10]:
        if size_mb > 0.1:  # Only show if > 0.1 MB
            print(f"  {name}: {size_mb:.2f} MB")
    
    return mem_gb

# %% ../../projects/utils/clean_mem.ipynb 6
import subprocess
from datetime import datetime

def get_all_kernels_memory():
    """Get memory usage of all running Jupyter kernels"""
    kernels = []
    total_mem_mb = 0
    
    try:
        # Get all ipykernel processes
        result = subprocess.run(
            ['ps', 'aux'], 
            capture_output=True, 
            text=True
        )
        
        lines = result.stdout.split('\n')
        current_pid = os.getpid()
        
        print("Running Jupyter Kernels:")
        print("-" * 90)
        print(f"{'PID':<8} {'Memory (MB)':<15} {'Memory (GB)':<15} {'CPU%':<8} {'Age':<15} {'Current'}")
        print("-" * 90)
        
        for line in lines:
            if 'ipykernel_launcher' in line and 'grep' not in line:
                parts = line.split()
                pid = int(parts[1])
                mem_kb = float(parts[5])
                mem_mb = mem_kb / 1024
                mem_gb = mem_mb / 1024
                cpu_percent = parts[2]
                
                total_mem_mb += mem_mb
                
                try:
                    proc = psutil.Process(pid)
                    create_time = datetime.fromtimestamp(proc.create_time())
                    age = datetime.now() - create_time
                    
                    if age.days > 0:
                        age_str = f"{age.days}d {age.seconds//3600}h"
                    elif age.seconds > 3600:
                        age_str = f"{age.seconds//3600}h {(age.seconds%3600)//60}m"
                    else:
                        age_str = f"{age.seconds//60}m {age.seconds%60}s"
                    
                    is_current = "←  YOU" if pid == current_pid else ""
                    
                    print(f"{pid:<8} {mem_mb:<15.2f} {mem_gb:<15.3f} {cpu_percent:<8} {age_str:<15} {is_current}")
                    
                    kernels.append({
                        'pid': pid,
                        'memory_mb': mem_mb,
                        'memory_gb': mem_gb,
                        'age': age_str,
                        'is_current': pid == current_pid
                    })
                except:
                    pass
        
        total_gb = total_mem_mb / 1024
        print("-" * 90)
        print(f"Total: {len(kernels)} kernels using {total_mem_mb:.2f} MB ({total_gb:.2f} GB)")
        print(f"Note: This is just process memory. Models/tensors can use much more!")
        
        return kernels
        
    except Exception as e:
        print(f"Error: {e}")
        return []


# %% ../../projects/utils/clean_mem.ipynb 9
def get_system_memory():
    """Get overall system memory status"""
    mem = psutil.virtual_memory()
    swap = psutil.swap_memory()
    
    print("System Memory Status:")
    print("=" * 60)
    print(f"Total RAM:      {mem.total / (1024**3):>10.2f} GB")
    print(f"Available:      {mem.available / (1024**3):>10.2f} GB")
    print(f"Used:           {mem.used / (1024**3):>10.2f} GB")
    print(f"Free:           {mem.free / (1024**3):>10.2f} GB")
    print(f"Usage:          {mem.percent:>10.1f}%")
    print()
    print(f"Swap Total:     {swap.total / (1024**3):>10.2f} GB")
    print(f"Swap Used:      {swap.used / (1024**3):>10.2f} GB")
    print(f"Swap Free:      {swap.free / (1024**3):>10.2f} GB")
    print(f"Swap Usage:     {swap.percent:>10.1f}%")
    print("=" * 60)
    
    # Memory pressure indicator
    if mem.percent > 90:
        print("⚠️  CRITICAL: Memory usage is very high!")
    elif mem.percent > 75:
        print("⚠️  WARNING: Memory usage is high")
    elif mem.percent > 50:
        print("✓  Memory usage is moderate")
    else:
        print("✓  Memory usage is healthy")
    
    return mem


# %% ../../projects/utils/clean_mem.ipynb 12
import gc

def clean_current_notebook(keep_functions=True):
    """Clean up memory in the current notebook
    
    Args:
        keep_functions: If True, keeps function definitions
    """
    print("Before cleanup:")
    mem_before = get_current_notebook_memory()
    
    # Get list of variables to delete
    to_delete = []
    for name in list(globals().keys()):
        if name.startswith('_'):
            continue
        if keep_functions and callable(globals()[name]) and not isinstance(globals()[name], type):
            continue
        if name in ['get_current_notebook_memory', 'get_all_kernels_memory', 
                    'get_system_memory', 'clean_current_notebook', 
                    'kill_specific_kernel', 'kill_all_kernels',
                    'os', 'psutil', 'sys', 'subprocess', 'datetime', 'gc']:
            continue
        to_delete.append(name)
    
    # Delete variables
    for name in to_delete:
        if name in globals():
            del globals()[name]
    
    # Try to clear PyTorch cache if available
    try:
        import torch
        if torch.cuda.is_available():
            torch.cuda.empty_cache()
            print("  ✓ Cleared CUDA cache")
    except:
        pass
    
    # Garbage collection
    collected = gc.collect()
    
    print(f"\n✓ Deleted {len(to_delete)} variables")
    print(f"✓ Garbage collector freed {collected} objects")
    
    print("\nAfter cleanup:")
    mem_after = get_current_notebook_memory()
    
    print(f"\n{'='*60}")
    print(f"Memory freed: {(mem_before - mem_after)*1024:.2f} MB")
    print(f"{'='*60}")


# %% ../../projects/utils/clean_mem.ipynb 15
def kill_specific_kernel(pid):
    """Kill a specific Jupyter kernel by PID
    
    Args:
        pid: Process ID to kill (int)
    """
    current_pid = os.getpid()
    
    if pid == current_pid:
        print(f"⚠️  Warning: PID {pid} is YOUR current notebook!")
        response = input("Are you sure you want to kill your own kernel? (yes/no): ")
        if response.lower() != 'yes':
            print("Cancelled.")
            return
    
    try:
        proc = psutil.Process(pid)
        mem_mb = proc.memory_info().rss / (1024**2)
        
        print(f"Killing kernel PID {pid} (using {mem_mb:.2f} MB)...")
        proc.terminate()
        proc.wait(timeout=3)
        print(f"✓ Successfully killed kernel {pid}")
        
    except psutil.NoSuchProcess:
        print(f"⚠️  Process {pid} not found")
    except Exception as e:
        print(f"Error: {e}")


# %% ../../projects/utils/clean_mem.ipynb 18
def kill_all_kernels(exclude_current=True):
    """Kill all Jupyter kernels
    
    Args:
        exclude_current: If True, don't kill the current notebook
    """
    current_pid = os.getpid()
    killed = []
    
    try:
        result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
        lines = result.stdout.split('\n')
        
        for line in lines:
            if 'ipykernel_launcher' in line and 'grep' not in line:
                parts = line.split()
                pid = int(parts[1])
                
                if exclude_current and pid == current_pid:
                    print(f"Skipping current notebook (PID: {pid})")
                    continue
                
                try:
                    proc = psutil.Process(pid)
                    mem_mb = proc.memory_info().rss / (1024**2)
                    proc.terminate()
                    killed.append((pid, mem_mb))
                    print(f"✓ Killed kernel {pid} (was using {mem_mb:.2f} MB)")
                except:
                    pass
        
        if killed:
            total_freed = sum(mem for _, mem in killed)
            print(f"\n{'='*60}")
            print(f"✓ Killed {len(killed)} kernel(s)")
            print(f"✓ Freed approximately {total_freed:.2f} MB of process memory")
            print(f"{'='*60}")
        else:
            print("No other kernels found to kill.")
            
    except Exception as e:
        print(f"Error: {e}")


# %% ../../projects/utils/clean_mem.ipynb 22
# Check specific variable sizes (useful for large models)
def check_variable_sizes(min_mb=10):
    """Show all variables larger than min_mb in current notebook"""
    print(f"Variables larger than {min_mb} MB:")
    print("-" * 50)
    
    import sys
    vars_size = []
    for name, obj in globals().items():
        if not name.startswith('_'):
            size_mb = sys.getsizeof(obj) / (1024**2)
            if size_mb > min_mb:
                vars_size.append((name, size_mb, type(obj).__name__))
    
    vars_size.sort(key=lambda x: x[1], reverse=True)
    
    for name, size_mb, obj_type in vars_size:
        print(f"{name:<20} {size_mb:>10.2f} MB  ({obj_type})")
    
    if not vars_size:
        print(f"No variables found > {min_mb} MB")

